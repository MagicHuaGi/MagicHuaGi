{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\ncontroller_1 = Controller(PRIMARY)\nintake = Motor(Ports.PORT8, GearSetting.RATIO_6_1, True)\nshoot_air = DigitalOut(brain.three_wire_port.a)\nLeftMotorGroup_motor_a = Motor(Ports.PORT1, GearSetting.RATIO_18_1, True)\nLeftMotorGroup_motor_b = Motor(Ports.PORT2, GearSetting.RATIO_18_1, True)\nLeftMotorGroup = MotorGroup(LeftMotorGroup_motor_a, LeftMotorGroup_motor_b)\nRightMotorGroup_motor_a = Motor(Ports.PORT9, GearSetting.RATIO_18_1, False)\nRightMotorGroup_motor_b = Motor(Ports.PORT10, GearSetting.RATIO_18_1, False)\nRightMotorGroup = MotorGroup(RightMotorGroup_motor_a, RightMotorGroup_motor_b)\nbounds_air = DigitalOut(brain.three_wire_port.h)\ninertial_6 = Inertial(Ports.PORT20)\nfw = Motor(Ports.PORT11, GearSetting.RATIO_6_1, True)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n#endregion VEXcode Generated Robot Configuration\n\n\nlasterror = 0\nintegral = 0\nderivative =  0 \nn1 = 0 \nn2 = 0\ndirection = 0\nauto_tp = 0\nshoot_ready = False\nauto_shoot_ready = False\nfw_spin = False\ntime_lock = False\nauto_flying_wheel_spin = Event()\n\n\n\n# 双色桶函数方法\ndef spin_other():\n    LeftMotorGroup.set_velocity(10, PERCENT)\n    RightMotorGroup.set_velocity(10, PERCENT)\n    LeftMotorGroup.spin(FORWARD)\n    RightMotorGroup.spin(FORWARD)\n    intake.set_velocity(100, PERCENT)\n    intake.spin(REVERSE)\n    wait(300,MSEC)\n    LeftMotorGroup.stop()\n    RightMotorGroup.stop()\n    intake.stop()\n\n\n\n\n\n# 转向函数方法\ndef turn_angle(angle):\n    global direction\n    error_turn = 2\n    direction = angle\n    kp_turn = 0.7\n    ks_turn = 2\n    while math.fabs(error_turn) > 1:\n        error_turn = angle - inertial_6.rotation(DEGREES)\n        if error_turn > 0:\n            ks_turn = math.fabs(ks_turn)\n        elif 0 > error_turn:\n            ks_turn = 0 - math.fabs(ks_turn)\n        else:\n            ks_turn = 0\n        output_turn = error_turn * kp_turn + ks_turn\n        \n        LeftMotorGroup.set_velocity(output_turn, PERCENT)\n        RightMotorGroup.set_velocity(-output_turn, PERCENT)\n        LeftMotorGroup.spin(FORWARD)\n        RightMotorGroup.spin(FORWARD)\n        wait(3,MSEC)\n    LeftMotorGroup.stop()\n    RightMotorGroup.stop()\n\n# 加速方法\ndef speed_up(up):\n    v = 0\n    if up > 0 :\n        for i in range(60):\n            v = v + 1\n            LeftMotorGroup.set_velocity(v + (direction - inertial_6.rotation(DEGREES))*1.5  , PERCENT)\n            RightMotorGroup.set_velocity(v - (direction - inertial_6.rotation(DEGREES))*1.5 , PERCENT)\n            LeftMotorGroup.spin(FORWARD)\n            RightMotorGroup.spin(FORWARD)\n            wait( 10, MSEC )\n    else :\n        for i in range(60):\n            v = v - 1\n            LeftMotorGroup.set_velocity(v - (direction - inertial_6.rotation(DEGREES)) *1.5 , PERCENT)\n            RightMotorGroup.set_velocity(v + (direction - inertial_6.rotation(DEGREES))*1.5 , PERCENT)\n            LeftMotorGroup.spin(FORWARD)\n            RightMotorGroup.spin(FORWARD)\n            wait( 10, MSEC )\n\n# 底盘编码器方法\ndef underpans(code):\n    kp_underpans = 0.3\n    ks_underpans = 3\n    error_underpans = code - LeftMotorGroup_motor_a.position(DEGREES)\n    LeftMotorGroup_motor_a.set_position(0,DEGREES)\n    if math.fabs(error_underpans) > 200:\n        if code > 0 : \n            speed_up(100)\n        elif code < 0 :\n            speed_up(-100)\n    while math.fabs(error_underpans) > 2 :\n        error_underpans = code - LeftMotorGroup_motor_a.position(DEGREES)\n        if error_underpans > 0 :\n            ks_underpans = math.fabs(ks_underpans)\n        elif error_underpans < 0 :\n            ks_underpans = -math.fabs(ks_underpans)\n        output_underpans = error_underpans * kp_underpans + ks_underpans\n\n        LeftMotorGroup.set_velocity(output_underpans + (direction - inertial_6.rotation(DEGREES))*1.5, PERCENT)\n        RightMotorGroup.set_velocity(output_underpans - (direction - inertial_6.rotation(DEGREES)) *1.5, PERCENT)\n        LeftMotorGroup.spin(FORWARD)\n        RightMotorGroup.spin(FORWARD)\n    LeftMotorGroup.stop()\n    RightMotorGroup.stop()\n    turn_angle(direction)\n\n# R1按下飞轮旋转   R2按下停止旋转\ndef onevent_controller_1buttonR1_pressed_0():\n    global lasterror,integral,derivative,tp,shoot_ready,kp_fw,ki_fw,kd_fw,error_fw,tp\n    dt_fw = 0.01\n    while True:\n        error_fw = tp - fw.velocity(RPM)\n        integral = integral + error_fw * dt_fw\n        derivative = (error_fw - lasterror) / dt_fw\n        output_fw = tp + error_fw * kp_fw + integral * ki_fw + derivative * kd_fw\n        fw.set_velocity(output_fw,RPM)\n        fw.spin(FORWARD)\n        lasterror = error_fw\n        if controller_1.buttonR2.pressing():\n            fw.stop()\n            shoot_ready = False\n            break\n        if math.fabs(error_fw) < 20:\n            shoot_ready = True\n        else:\n            shoot_ready = False \n        print(\"P:{:.2f} I:{:.2f} D:{:.2f} V:{:.2f} T:{:.0f}\".format(error_fw * kp_fw , integral * ki_fw , derivative * kd_fw , fw.velocity(RPM)*6,fw.temperature(PERCENT)))\n        wait(dt_fw,SECONDS)\n    \n# 底盘移动时间控制方法，单位为秒\ndef time_underpans(sec = 0.7):\n    LeftMotorGroup.set_velocity(50, PERCENT)\n    RightMotorGroup.set_velocity(50, PERCENT)\n    LeftMotorGroup.spin(FORWARD)\n    RightMotorGroup.spin(FORWARD)\n    wait(sec, SECONDS)\n    LeftMotorGroup.stop()\n    RightMotorGroup.stop()\n\n# 底盘直接移动方式\ndef move(c,v = 30):\n    LeftMotorGroup.set_position(0,DEGREES)\n    RightMotorGroup.set_position(0,DEGREES)\n    LeftMotorGroup.set_velocity(v + (direction - inertial_6.rotation(DEGREES))*0.5 , PERCENT)\n    RightMotorGroup.set_velocity(v - (direction - inertial_6.rotation(DEGREES))*0.5 , PERCENT)\n    LeftMotorGroup.spin_for(FORWARD,c,DEGREES,wait=False)\n    RightMotorGroup.spin_for(FORWARD,c,DEGREES)\n    LeftMotorGroup.stop()\n    RightMotorGroup.stop()\n\n# 自动阶段飞轮旋转\ndef event_auto_flying_wheel_spin():\n    global lasterror,integral,derivative,auto_tp,auto_shoot_ready,kp_fw,ki_fw,kd_fw,error_fw,fw_spin\n    kp_fw =  0.1\n    ki_fw = 0.02\n    kd_fw =  0.01\n    dt = 0.01\n    while True:\n        error_fw = auto_tp - fw.velocity(RPM)\n        integral = integral + error_fw * dt\n        derivative = (error_fw - lasterror) / dt\n        output_fw = auto_tp + error_fw * kp_fw + integral * ki_fw + derivative * kd_fw\n        fw.set_velocity(output_fw,RPM)\n        fw.spin(FORWARD)\n        lasterror = error_fw\n        if fw_spin:\n            fw.stop()\n            break\n        if math.fabs(error_fw) < 15:\n            auto_shoot_ready = True\n        else:\n            auto_shoot_ready = False\n        wait(dt,SECONDS)\n        \n\n# 自动阶段计数发射\ndef auto_flying_wheel_shoot(count):\n    global auto_shoot_ready\n    i = 0 \n    while i < count :\n        if auto_shoot_ready:\n            shoot_air.set(True)\n            wait(0.15,SECONDS)\n            shoot_air.set(False)\n            wait(0.2,SECONDS)\n            i = i + 1\n\n# 收取结构\ndef onevent_controller_1buttonL1_pressed_0():\n    global n1 , n2\n    n1 = n1 + 1\n    if n1 % 2 == 1 :\n        intake.set_velocity(80,PERCENT)\n        intake.spin(FORWARD)\n    else:\n        intake.stop()\n    n2 = 0  \n\ndef onevent_controller_1buttonL2_pressed_0(): \n    global n1 , n2\n    n2 = n2 + 1\n    if n2 % 2 == 1 :\n        intake.set_velocity(80,PERCENT)\n        intake.spin(REVERSE)\n    else:\n        intake.stop()\n    n1 = 0\n\n# 初始化\ndef when_started1():\n    global tp,reset_time,display_near,display_far,kp_fw,ki_fw,kd_fw\n    display_near = True\n    display_far = False\n    LeftMotorGroup.set_stopping(BRAKE)\n    RightMotorGroup.set_stopping(BRAKE)\n    intake.set_stopping(HOLD)\n    intake.set_max_torque(100,PERCENT)\n    fw.set_stopping(COAST)\n    shoot_air.set(False)\n    bounds_air.set(False)\n    inertial_6.calibrate()\n    tp = 380\n    kp_fw =  0.1\n    ki_fw = 0.02\n    kd_fw =  0.01\n    reset_time = 0.16\n\n    \n\n# 遥控程序\ndef ondriver_drivercontrol_0():\n    global time_lock , reset_time , n1 , n2,display_near,display_far ,shoot_ready,kp_fw,ki_fw,kd_fw,reset_time,tp\n    brain.timer.clear()\n    while True :\n        # 底盘遥控\n        y = controller_1.axis3.position()\n        x = controller_1.axis1.position() * 0.55\n        if math.fabs(y) > 10 or math.fabs(x) > 10 :\n            LeftMotorGroup.set_velocity( y + x , PERCENT )\n            RightMotorGroup.set_velocity( y - x , PERCENT )\n            LeftMotorGroup.spin(FORWARD)\n            RightMotorGroup.spin(FORWARD)\n\n        else :\n            LeftMotorGroup.stop()\n            RightMotorGroup.stop()\n\n        # 发射远近两档按键调节\n        if controller_1.buttonUp.pressing():\n            tp = 550\n            kp_fw =  0.11\n            ki_fw = 0.02\n            kd_fw =   0.01\n            reset_time = 0.2      \n            display_far = True\n            display_near = False\n        if controller_1.buttonDown.pressing():\n            tp = 380\n            kp_fw =  0.1\n            ki_fw = 0.02\n            kd_fw =  0.01\n            reset_time = 0.16\n            display_near = True\n            display_far = False\n            \n        # 飞盘发射\n        if controller_1.buttonX.pressing() and shoot_ready:\n            shoot_air.set(True)\n            wait(0.16,SECONDS)\n            shoot_air.set(False)\n            wait(reset_time,SECONDS)\n        \n        # 占领时间锁与自动占领弹射\n        if brain.timer.time(SECONDS) > 90 :\n            time_lock = True\n\n        # 占领弹射\n        if controller_1.buttonB.pressing() and time_lock :\n            bounds_air.set(True) \n        wait(5,MSEC)\n\n# 自动阶段，红色联盟短边\ndef onauton_autonomous_0():\n    global auto_tp,fw_spin \n     # step1 前进并发射\n    auto_tp = 565\n    auto_flying_wheel_spin.broadcast()\n    underpans(-500)\n    turn_angle(-90)\n    time_underpans(0.2)\n    spin_other()\n    move(-80,100)\n    turn_angle(-86)\n    auto_flying_wheel_shoot(2)\n    auto_tp = 503\n    # step3 调整姿态面向飞盘直线\n    move(45,100)\n    turn_angle(40)\n    intake.set_velocity(100,PERCENT)\n    intake.spin(FORWARD)\n    move(1550,32)\n    turn_angle(-46)\n    auto_flying_wheel_shoot(3)\n    tp = 380\n    fw_spin = True\n    intake.stop()\n# 打印与反馈线程\ndef when_started2():\n    global display_near,display_far,error_fw,kp_fw,integral,ki_fw,derivative,kd_fw\n    while True :        \n        # RC_1 输出部分\n        controller_1.screen.clear_screen()\n        controller_1.screen.set_cursor(1,1)\n        controller_1.screen.print(\"LM:\"+ str(LeftMotorGroup.position(DEGREES))+\"  RM:\"+ str(RightMotorGroup.position(DEGREES)))\n        controller_1.screen.next_row()\n        controller_1.screen.print(\"Gyro:\"+ str(inertial_6.rotation(DEGREES)))  \n        # RC_2 输出部分\n        if display_near  :\n            controller_1.screen.clear_screen()\n            controller_1.screen.set_cursor(3,7)\n            controller_1.screen.print(\"Near\")\n        if display_far :\n            controller_1.screen.clear_screen()\n            controller_1.screen.set_cursor(3,7)\n            controller_1.screen.print(\"Far\")   \n        \"\"\"\n        print(\"LFV:{:.1f} LBV:{:.1f} RFV:{:.1f} RBV:{:.1f}\".format(LeftMotorGroup_motor_a.velocity(RPM),LeftMotorGroup_motor_b.velocity(RPM),RightMotorGroup_motor_a.velocity(RPM),RightMotorGroup_motor_b.velocity(RPM) ))\n        print(\"LFP:{:.1f} LBP:{:.1f} RFP:{:.1f} RBP:{:.1f} A:{:.1f}\".format(LeftMotorGroup_motor_a.position(DEGREES),LeftMotorGroup_motor_b.position(DEGREES),RightMotorGroup_motor_a.position(DEGREES),RightMotorGroup_motor_b.position(DEGREES), inertial_6.rotation(DEGREES)))\n        \"\"\"\n        wait(0.1, SECONDS)    \n\n\n# create a function for handling the starting and stopping of all autonomous tasks\ndef vexcode_auton_function():\n    # Start the autonomous control tasks\n    auton_task_0 = Thread( onauton_autonomous_0 )\n    # wait for the driver control period to end\n    while( competition.is_autonomous() and competition.is_enabled() ):\n        # wait 10 milliseconds before checking again\n        wait( 10, MSEC )\n    # Stop the autonomous control tasks\n    auton_task_0.stop()\n\ndef vexcode_driver_function():\n    # Start the driver control tasks\n    driver_control_task_0 = Thread( ondriver_drivercontrol_0 )\n\n    # wait for the driver control period to end\n    while( competition.is_driver_control() and competition.is_enabled() ):\n        # wait 10 milliseconds before checking again\n        wait( 10, MSEC )\n    # Stop the driver control tasks\n    driver_control_task_0.stop()\n\n\n# register the competition functions\ncompetition = Competition( vexcode_driver_function, vexcode_auton_function )\n\n# system event handlers\ncontroller_1.buttonR1.pressed(onevent_controller_1buttonR1_pressed_0)\ncontroller_1.buttonL1.pressed(onevent_controller_1buttonL1_pressed_0)\ncontroller_1.buttonL2.pressed(onevent_controller_1buttonL2_pressed_0)\nauto_flying_wheel_spin(event_auto_flying_wheel_spin)\n# add 15ms delay to make sure events are registered correctly.\nwait(15, MSEC)\nws2 = Thread( when_started2 )\nwhen_started1()\n","textLanguage":"python","rconfig":[{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[8],"name":"intake","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"正","rev":"反","gear":"ratio6_1"},"triportSourcePort":22},{"port":[1],"name":"shoot_air","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[1,2],"name":"LeftMotorGroup","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"正","rev":"反","gear":"ratio18_1","motor_a_reversed":"true","motor_b_reversed":"true"},"triportSourcePort":22},{"port":[9,10],"name":"RightMotorGroup","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"正","rev":"反","gear":"ratio18_1","motor_a_reversed":"false","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[8],"name":"bounds_air","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[20],"name":"inertial_6","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22},{"port":[11],"name":"fw","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"正","rev":"反","gear":"ratio6_1"},"triportSourcePort":22}],"slot":2,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"2.4.5","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","target":"Physical"}